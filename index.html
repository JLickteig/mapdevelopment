<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Salas O'Brien Offices Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- OpenLayers -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@latest/ol.css" />
  <script src="https://cdn.jsdelivr.net/npm/ol@latest/dist/ol.js"></script>

  <!-- Proj4 for Lambert Conformal Conic -->
  <script src="https://cdn.jsdelivr.net/npm/proj4@2.9.2/dist/proj4.js"></script>

  <!-- html2canvas for export -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

  <!-- Pickr (Color Picker) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/themes/classic.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/pickr.min.js"></script>

  <!-- Turf -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <!-- CSV parser -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>

  <style>
    :root {
      --brand: #009de0;
      --bg: #ffffff;
      --text: #111;
      --muted: #666;
      --line: #e5e7eb;
      --shadow: 0 4px 12px rgba(0,0,0,0.08);
      --radius: 14px;
    }

    * { box-sizing: border-box; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color: var(--text); }

    #map {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
    }

    #panel {
      position: absolute;
      top: 14px; left: 14px;
      width: 320px;
      max-height: calc(100vh - 28px);
      overflow: auto;
      background: var(--bg);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px;
      z-index: 5;
    }
    .panel-section {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 12px;
      margin-bottom: 12px;
      background: #fff;
    }
    .section-title {
      font-weight: 600;
      font-size: 14px;
      margin: 0 0 8px 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .hr { height: 1px; background: var(--line); margin: 12px 0; }

    .segmented {
      display: inline-flex;
      border: 1.5px solid var(--brand);
      border-radius: 999px;
      overflow: hidden;
      user-select: none;
    }
    .segmented button {
      padding: 8px 12px;
      font-size: 13px;
      border: none;
      background: #fff;
      color: var(--brand);
      cursor: pointer;
    }
    .segmented button.active { background: var(--brand); color: #fff; }

    .so-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      width: 100%;
      padding: 10px 14px;
      font-size: 14px;
      color: #000;
      background: #fff;
      border: 2px solid var(--brand);
      border-radius: 999px;
      cursor: pointer;
      transition: background .15s, color .15s;
    }
    .so-btn:hover { background: var(--brand); color: #fff; }

    .accordion { border: 1px solid var(--line); border-radius: 10px; overflow: hidden; margin-bottom: 10px; }
    .accordion-header {
      display: flex; align-items: center; justify-content: space-between;
      padding: 10px 12px; cursor: pointer; background: #f8fafc;
      font-weight: 600; font-size: 14px;
    }
    .chev { width: 12px; height: 12px; background: var(--brand); clip-path: polygon(100% 100%, 100% 0, 0 100%); transition: transform .15s; }
    .accordion-header[aria-expanded="true"] .chev { transform: rotate(45deg); }
    .accordion-body { display: none; padding: 10px; }
    .accordion-header[aria-expanded="true"] + .accordion-body { display: block; }

    label { font-size: 13px; font-weight: 600; }
    .subhead { color: var(--muted); font-size: 12px; }
    select { width: 100%; min-height: 160px; font-size: 13px; }
    .muted { color: var(--muted); font-size: 12px; }

    input[type="file"] { width: 100%; font-size: 13px; }
    input[type="file"]::file-selector-button {
      font-size: 12px; font-weight: 600; color: #000; background: #fff;
      border: 2px solid var(--brand); border-radius: 999px; padding: 6px 12px; margin-right: 10px; cursor: pointer;
      transition: background .15s, color .15s;
    }
    input[type="file"]::file-selector-button:hover { background: var(--brand); color: #fff; }

    .layer-card { border: 1px solid var(--line); border-radius: 10px; padding: 10px; margin-bottom: 10px; background: #fff; }
    .layer-header { display: flex; align-items: center; justify-content: space-between; gap: 8px; margin-bottom: 8px; }
    .layer-meta { display: flex; align-items: center; gap: 8px; min-width: 0; }
    .badge { font-size: 11px; color: #444; background: #f1f5f9; border:1px solid #e5e7eb; border-radius: 999px; padding: 2px 8px; }
    .layer-name-input { border:1px solid #e5e7eb; border-radius:8px; padding:6px 8px; width: 180px; }
    .layer-actions { display: flex; align-items: center; gap: 8px; }

    .icon-btn {
      background:#fff;
      border:1px solid var(--line);
      border-radius:8px;
      width:32px;
      height:32px;
      padding:0;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
    }
    .icon-btn:hover{ background:#f3f4f6; }
    .icon-btn svg{ width:18px; height:18px; display:block; fill:currentColor; }

    .layer-body { display: grid; gap: 8px; }
    .layer-row { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }

    .map-legend {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 14px;
      background: transparent;
      border-radius: 10px;
      padding: 8px 10px;
      z-index: 4;
      max-width: min(90%, 900px);
    }
    #legendItems { display: flex; align-items: center; justify-content: center; flex-wrap: wrap; gap: 10px 16px; }
    .legend-item { display: inline-flex; align-items: center; gap: 6px; }
    .legend-swatch { width: 14px; height: 14px; border-radius: 3px; display: inline-block; }

    .pcr-app { z-index: 10002; }

    #popup {
      position:absolute;
      background:white;
      border:1px solid #ccc;
      padding:6px 10px;
      font-size:12px;
      border-radius:6px;
      box-shadow:0 2px 6px rgba(0,0,0,0.2);
      pointer-events:none;
      display:none;
      z-index:10;
    }
  </style>
</head>
<body>
  <aside id="panel">
    <div class="panel-section">
      <div class="section-title">Coverage (3-hour drive)</div>
      <div class="segmented">
        <button id="reachOff" class="active">Hide Reach</button>
        <button id="reachOn">Show Reach</button>
      </div>
      <div class="muted" style="margin-top:6px;">Shows a 3-hour driving area around offices.</div>
    </div>
	
<div class="panel-section">
  <div class="section-title">Other Countries</div>
  <div class="segmented">
    <button id="countriesOff" class="active">Hide Countries</button>
    <button id="countriesOn">Show Countries</button>
  </div>
  <div id="countrySelectContainer" style="display:none; margin-top:10px;">
    <label class="subhead">(Ctrl/Cmd + click for multiple)</label>
    <select id="countryFilter" multiple size="8"></select>
    <div style="margin-top:8px;">
      <button class="so-btn" id="clearCountries">Clear Selection</button>
    </div>
  </div>
  <div class="muted" style="margin-top:6px;">Show additional countries beyond US and Canada.</div>
</div>

    <div class="panel-section">
      <div class="section-title">Filters</div>

      <div class="accordion">
        <div class="accordion-header" aria-expanded="false">
          <span>State / Province</span>
          <span class="chev"></span>
        </div>
        <div class="accordion-body">
          <label class="subhead">(Ctrl/Cmd + click for multiple)</label>
          <select id="regionFilter" multiple></select>
          <div style="margin-top:8px; display:flex; gap:8px;">
            <button class="so-btn" id="clearRegion">Clear</button>
          </div>
        </div>
      </div>

      <div class="accordion">
        <div class="accordion-header" aria-expanded="false">
          <span>Business Unit</span>
          <span class="chev"></span>
        </div>
        <div class="accordion-body">
          <select id="buFilter" multiple size="6"></select>
          <div style="margin-top:8px; display:flex; gap:8px;">
            <button class="so-btn" id="clearBU">Clear</button>
          </div>
        </div>
      </div>

      <div class="hr"></div>
      <button class="so-btn" id="clearFilters">Clear All Filters</button>
    </div>

    <div class="panel-section">
      <div class="section-title">Layers</div>

      <div class="layer-card">
        <div class="layer-header">
          <div class="layer-meta">
            <strong>Salas O'Brien Offices</strong>
            <span style="font-size:10px; color:#666">Built-in</span>
          </div>
          <div class="layer-actions">
            <button class="icon-btn" id="toggle-offices" title="Toggle visibility"></button>
          </div>
        </div>
        <div class="muted">This layer is filterable.</div>
      </div>

      <div id="uploadLayers"></div>

      <button class="so-btn" id="addLayerBtn">+ Add Layer</button>
      <div style="height:8px;"></div>
      <a href="#" id="downloadTemplate" class="muted" style="color:#E35920; font-weight: bold;">Download CSV template</a>
      <div class="muted" style="margin-top:6px;">
        Add up to 3 more layers. <br>
        <span style="color:#E35920; font-weight: bold;">NOTE</span> Template use is required.
      </div>
    </div>

    <div class="panel-section">
      <button class="so-btn" id="exportMap">Export Map as PNG</button>
      <button class="so-btn" id="revertMap" style="margin-top:8px;">Revert to Base Map</button>
    </div>
  </aside>

  <div id="map"></div>
  <div id="popup"></div>
  <div id="legend" class="map-legend" style="display:none;">
    <div id="legendItems"></div>
  </div>

  <script>
    // ADD YOUR GOOGLE MAPS API KEY HERE (WARNING: This is visible to anyone viewing your page source)
    const GOOGLE_MAPS_KEY = 'AIzaSyBZVs1es2OML0d7tQSw7BF38lUlx8-BW-U';
    
    const ICON_EYE = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640"><path d="M320 96C239.2 96 174.5 132.8 127.4 176.6C80.6 220.1 49.3 272 34.4 307.7C31.1 315.6 31.1 324.4 34.4 332.3C49.3 368 80.6 420 127.4 463.4C174.5 507.1 239.2 544 320 544C400.8 544 465.5 507.2 512.6 463.4C559.4 419.9 590.7 368 605.6 332.3C608.9 324.4 608.9 315.6 605.6 307.7C590.7 272 559.4 220 512.6 176.6C465.5 132.9 400.8 96 320 96zM176 320C176 240.5 240.5 176 320 176C399.5 176 464 240.5 464 320C464 399.5 399.5 464 320 464C240.5 464 176 399.5 176 320zM320 256C320 291.3 291.3 320 256 320C244.5 320 233.7 317 224.3 311.6C223.3 322.5 224.2 333.7 227.2 344.8C240.9 396 293.6 426.4 344.8 412.7C396 399 426.4 346.3 412.7 295.1C400.5 249.4 357.2 220.3 311.6 224.3C316.9 233.6 320 244.4 320 256z"/></svg>`;
    const ICON_EYE_OFF = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path d="M41-24.9c-9.4-9.4-24.6-9.4-33.9 0S-2.3-.3 7 9.1l528 528c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-96.4-96.4c2.7-2.4 5.4-4.8 8-7.2 46.8-43.5 78.1-95.4 93-131.1 3.3-7.9 3.3-16.7 0-24.6-14.9-35.7-46.2-87.7-93-131.1-47.1-43.7-111.8-80.6-192.6-80.6-56.8 0-105.6 18.2-146 44.2L41-24.9zM204.5 138.7c23.5-16.8 52.4-26.7 83.5-26.7 79.5 0 144 64.5 144 144 0 31.1-9.9 59.9-26.7 83.5l-34.7-34.7c12.7-21.4 17-47.7 10.1-73.7-13.7-51.2-66.4-81.6-117.6-67.9-8.6 2.3-16.7 5.7-24 10l-34.7-34.7zM325.3 395.1c-11.9 3.2-24.4 4.9-37.3 4.9-79.5 0-144-64.5-144-144 0-12.9 1.7-25.4 4.9-37.3L69.4 139.2c-32.6 36.8-55 75.8-66.9 104.5-3.3 7.9-3.3 16.7 0 24.6 14.9 35.7 46.2 87.7 93 131.1 47.1 43.7 111.8 80.6 192.6 80.6 37.3 0 71.2-7.9 101.5-20.6l-64.2-64.2z"/></svg>`;

    // Projection setup
    proj4.defs("EPSG:102009", "+proj=lcc +lat_1=33 +lat_2=45 +lat_0=39 +lon_0=-96 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs");
    ol.proj.proj4.register(proj4);
    const lccProjection = ol.proj.get("EPSG:102009");

    // Layers
const statesProvincesLayer = new ol.layer.Vector({
  source: new ol.source.Vector({
    url: "https://raw.githubusercontent.com/JLickteig/SalasOBrienOfficeMap/main/statesandprovinces.geojson",
    format: new ol.format.GeoJSON()
  }),
  style: new ol.style.Style({
    stroke: new ol.style.Stroke({ color: "#CCCCCC", width: 0.5 }),
    fill: new ol.style.Fill({ color: "#EDEDED" })
  })
});

const greatLakesLayer = new ol.layer.Vector({
  source: new ol.source.Vector({
    url: "https://raw.githubusercontent.com/JLickteig/SalasOBrienOfficeMap/main/greatlakes.geojson",
    format: new ol.format.GeoJSON()
  }),
  style: new ol.style.Style({
    stroke: new ol.style.Stroke({ color: "#CCCCCC", width: 0.5 }),
    fill: new ol.style.Fill({ color: "#FFFFFF" })
  })
});

const countriesLayer = new ol.layer.Vector({
  source: new ol.source.Vector({
    url: "https://raw.githubusercontent.com/JLickteig/SalasOBrienOfficeMap/main/countries.geojson",
    format: new ol.format.GeoJSON()
  }),
  style: new ol.style.Style({
    stroke: new ol.style.Stroke({ color: "#CCCCCC", width: 1 }),
    fill: new ol.style.Fill({ color: "transparent" })
  })
});
    const haloLayer = new ol.layer.Vector({
      source: new ol.source.Vector(),
      style: new ol.style.Style({
        fill: new ol.style.Fill({ color: 'rgba(0, 157, 224, 0.2)' })
      })
    });

    const officeLayer = new ol.layer.Vector({
      source: new ol.source.Vector({
        url: "https://raw.githubusercontent.com/JLickteig/SalasOBrienOfficeMap/main/offices.geojson",
        format: new ol.format.GeoJSON()
      }),
      style: new ol.style.Style({
        image: new ol.style.Circle({
          radius: 6,
          fill: new ol.style.Fill({ color: "#009DE0" }),
          stroke: new ol.style.Stroke({ color: "#EDEDED", width: 0.5 })
        })
      })
    });

    const map = new ol.Map({
      target: 'map',
      layers: [statesProvincesLayer, greatLakesLayer, countriesLayer, haloLayer, officeLayer],
      view: new ol.View({
        projection: lccProjection,
        center: ol.proj.fromLonLat([-105, 42], lccProjection),
        zoom: 5.25
      })
    });

    // Fix Canvas2D performance warning
    map.once('rendercomplete', function() {
      const canvases = document.querySelectorAll('#map canvas');
      canvases.forEach(canvas => {
        const ctx = canvas.getContext('2d');
        if (ctx) {
          canvas.getContext('2d', { willReadFrequently: true });
        }
      });
    });

    // State
    let originalGeojson = null;
    let reachEnabled = false;
	let layerCount = 0;
    const MAX_LAYERS = 3;
    const uploadLayers = [];
    const isoCache = new Map();

    // Popup
    const popupEl = document.getElementById('popup');
    map.on('pointermove', function (evt) {
      const feature = map.forEachFeatureAtPixel(evt.pixel, f => f);
      if (feature && feature.getGeometry().getType() === 'Point') {
        const p = feature.getProperties();
        const name = p["OFFICE NAME"] || p.officeName || p.LABEL || '';
        const address = p.ADDRESS || p.address || '';
        const phone = p["MAIN PHONE"] || '';
        const bu = p.BU || p.bu || '';
        const color = p.color || '#009DE0';

        popupEl.innerHTML = `
          <div style="line-height:1.2;">
            <div style="font-weight:bold; color:${color};">${name}</div>
            <div style="font-size:11px; color:#333;">${address}</div>
            ${phone ? `<div style="font-size:11px; color:#666;">${phone}</div>` : ''}
            ${bu ? `<div style="font-size:11px; color:#666;">${bu}</div>` : ''}
          </div>
        `;
        popupEl.style.left = evt.pixel[0] + 12 + 'px';
        popupEl.style.top = evt.pixel[1] + 12 + 'px';
        popupEl.style.display = 'block';
        map.getTargetElement().style.cursor = 'pointer';
      } else {
        popupEl.style.display = 'none';
        map.getTargetElement().style.cursor = '';
      }
    });

    // Accordion
    document.querySelectorAll('.accordion-header').forEach(h => {
      h.addEventListener('click', () => {
        const expanded = h.getAttribute('aria-expanded') === 'true';
        h.setAttribute('aria-expanded', String(!expanded));
      });
    });

    // Helper functions
    function emptyFC() {
      return { type: 'FeatureCollection', features: [] };
    }

    async function fetchIsochronePolygon(lng, lat) {
      const key = `${lng.toFixed(6)},${lat.toFixed(6)}`;
      if (isoCache.has(key)) return isoCache.get(key);
      const circle = turf.circle([lng, lat], 289.7, { steps: 128, units: 'kilometers' });
      isoCache.set(key, circle);
      return circle;
    }

    async function buildIsochronesForPoints(points) {
      const polys = [];
      for (const f of points) {
        const [lng, lat] = f.geometry.coordinates;
        const poly = await fetchIsochronePolygon(lng, lat);
        polys.push(poly);
      }
      return { type: 'FeatureCollection', features: polys };
    }

    function dissolvePolygons(fc) {
      if (!fc?.features?.length) return emptyFC();
      let merged = fc.features[0];
      for (let i = 1; i < fc.features.length; i++) {
        try {
          merged = turf.union(merged, fc.features[i]);
        } catch (e) {
          console.warn('union failed', e);
        }
      }
      return merged ? { type: 'FeatureCollection', features: [merged] } : emptyFC();
    }

    function setHaloData(fc) {
      const format = new ol.format.GeoJSON();
      const features = format.readFeatures(fc, {
        featureProjection: lccProjection,
        dataProjection: 'EPSG:4326'
      });
      haloLayer.getSource().clear();
      haloLayer.getSource().addFeatures(features);
    }

    async function rebuildOfficeHalos(sourceData) {
      if (!reachEnabled || !officeLayer.getVisible()) {
        setHaloData(emptyFC());
        return;
      }

      let features;
      if (sourceData) {
        features = sourceData.features;
      } else {
        const format = new ol.format.GeoJSON();
        const gj = format.writeFeaturesObject(officeLayer.getSource().getFeatures(), {
          featureProjection: lccProjection,
          dataProjection: 'EPSG:4326'
        });
        features = gj.features;
      }

      const pts = features.filter(f => f.geometry?.type === 'Point');
      if (!pts.length) {
        setHaloData(emptyFC());
        return;
      }

      const fc = await buildIsochronesForPoints(pts);
      const dissolved = dissolvePolygons(fc);
      setHaloData(dissolved);
    }

    // Reach toggle
    function setReach(enabled) {
      reachEnabled = enabled;
      document.getElementById('reachOn').classList.toggle('active', enabled);
      document.getElementById('reachOff').classList.toggle('active', !enabled);

      if (!enabled) {
        setHaloData(emptyFC());
      } else {
        rebuildOfficeHalos();
      }
    }

    document.getElementById('reachOn').addEventListener('click', () => setReach(true));
    document.getElementById('reachOff').addEventListener('click', () => setReach(false));
	
	// Country filtering


function applyCountryFilter() {
  const countrySelect = document.getElementById('countryFilter');
  selectedCountries = new Set(Array.from(countrySelect.selectedOptions).map(o => o.value));
  updateBaseLayerStyle();
}

function updateBaseLayerStyle() {
  baseLayer.setStyle(function(feature) {
    const adminLevel = feature.get('admin_level');
    
    // For country boundaries (admin_level 0), check geographic bounds
    if (adminLevel === 0) {
      const extent = feature.getGeometry().getExtent();
      const center = [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
      const lonLat = ol.proj.toLonLat(center, lccProjection);
      
      // US/Canada longitude range (roughly -170 to -50)
      // US/Canada latitude range (roughly 25 to 85)
      const isNorthAmerica = lonLat[0] >= -170 && lonLat[0] <= -50 && 
                             lonLat[1] >= 25 && lonLat[1] <= 85;
      
      const shouldShow = isNorthAmerica || showOtherCountries;
      
      return new ol.style.Style({
        stroke: new ol.style.Stroke({ color: "#CCCCCC", width: 0.5 }),
        fill: new ol.style.Fill({ color: shouldShow ? "#EDEDED" : "transparent" })
      });
    }
    
    // For state/province boundaries (admin_level 1), always show them
    return new ol.style.Style({
      stroke: new ol.style.Stroke({ color: "#CCCCCC", width: 0.5 }),
      fill: new ol.style.Fill({ color: "#EDEDED" })
    });
  });
}

function setShowOtherCountries(enabled) {
  showOtherCountries = enabled;
  document.getElementById('countriesOn').classList.toggle('active', enabled);
  document.getElementById('countriesOff').classList.toggle('active', !enabled);
  document.getElementById('countrySelectContainer').style.display = enabled ? 'block' : 'none';
  
  if (!enabled) {
    selectedCountries.clear();
    document.getElementById('countryFilter').selectedIndex = -1;
  }
  
  updateBaseLayerStyle();
}

document.getElementById('countriesOn').addEventListener('click', () => setShowOtherCountries(true));
document.getElementById('countriesOff').addEventListener('click', () => setShowOtherCountries(false));

document.getElementById('clearCountries').addEventListener('click', () => {
  selectedCountries.clear();
  document.getElementById('countryFilter').selectedIndex = -1;
  updateBaseLayerStyle();
});

    // Office visibility toggle
    function updateOfficesToggleIcon(show) {
      const btn = document.getElementById('toggle-offices');
      btn.innerHTML = show ? ICON_EYE : ICON_EYE_OFF;
      btn.title = show ? 'Hide markers' : 'Show markers';
    }

    function setOfficesVisibility(show) {
      officeLayer.setVisible(show);
      if (!show) {
        setHaloData(emptyFC());
      } else if (reachEnabled) {
        rebuildOfficeHalos();
      }
      updateOfficesToggleIcon(show);
      updateLegend();
    }

    document.getElementById('toggle-offices').addEventListener('click', () => {
      setOfficesVisibility(!officeLayer.getVisible());
    });

    // Initialize
    setOfficesVisibility(true);
	
	// Load base layer and build country list
baseLayer.getSource().once('change', function() {
  if (baseLayer.getSource().getState() === 'ready') {
    const format = new ol.format.GeoJSON();
    baseGeoJSON = format.writeFeaturesObject(baseLayer.getSource().getFeatures(), {
      featureProjection: lccProjection,
      dataProjection: 'EPSG:4326'
    });
  }
});

    // Load offices data
    officeLayer.getSource().once('change', function() {
      if (officeLayer.getSource().getState() === 'ready') {
        const format = new ol.format.GeoJSON();
        originalGeojson = format.writeFeaturesObject(officeLayer.getSource().getFeatures(), {
          featureProjection: lccProjection,
          dataProjection: 'EPSG:4326'
        });
        buildFilters(originalGeojson);
        updateLegend();
      }
    });

    // Filters
    function buildFilters(gj) {
      const regionSelect = document.getElementById('regionFilter');
      const buSelect = document.getElementById('buFilter');

      const states = [...new Set(gj.features.filter(f => f.properties.COUNTRY === 'US').map(f => f.properties["STATE / PROVINCE"]).filter(Boolean))].sort();
      const provinces = [...new Set(gj.features.filter(f => f.properties.COUNTRY === 'CAN').map(f => f.properties["STATE / PROVINCE"]).filter(Boolean))].sort();
      const bus = [...new Set(gj.features.map(f => f.properties.BU).filter(Boolean))].sort();

      const caGroup = document.createElement('optgroup');
      caGroup.label = 'Canada';
      provinces.forEach(p => {
        const o = document.createElement('option');
        o.value = 'CAN|' + p;
        o.textContent = p;
        caGroup.appendChild(o);
      });

      const usGroup = document.createElement('optgroup');
      usGroup.label = 'United States';
      states.forEach(s => {
        const o = document.createElement('option');
        o.value = 'US|' + s;
        o.textContent = s;
        usGroup.appendChild(o);
      });

      regionSelect.appendChild(caGroup);
      regionSelect.appendChild(usGroup);

      bus.forEach(b => {
        const o = document.createElement('option');
        o.value = b;
        o.textContent = b;
        buSelect.appendChild(o);
      });

      function getSelected(select) {
        return Array.from(select.selectedOptions).map(o => o.value);
      }

      async function applyFilters() {
        const regionsRaw = getSelected(regionSelect);
        const regions = regionsRaw.map(v => v.split('|')[1]);
        const busSel = getSelected(buSelect);

        const filtered = {
          type: 'FeatureCollection',
          features: originalGeojson.features.filter(f => {
            const props = f.properties || {};
            let ok = true;
            if (regions.length) {
              const code = props["STATE / PROVINCE"] || '';
              if (!regions.includes(code)) ok = false;
            }
            if (busSel.length && props.BU && !busSel.includes(props.BU)) ok = false;
            return ok;
          })
        };

        const format = new ol.format.GeoJSON();
        const features = format.readFeatures(filtered, {
          featureProjection: lccProjection,
          dataProjection: 'EPSG:4326'
        });
        officeLayer.getSource().clear();
        officeLayer.getSource().addFeatures(features);

        if (reachEnabled && officeLayer.getVisible()) await rebuildOfficeHalos(filtered);
      }

      document.getElementById('clearRegion').addEventListener('click', () => {
        regionSelect.selectedIndex = -1;
        applyFilters();
      });
      document.getElementById('clearBU').addEventListener('click', () => {
        buSelect.selectedIndex = -1;
        applyFilters();
      });
      document.getElementById('clearFilters').addEventListener('click', () => {
        regionSelect.selectedIndex = -1;
        buSelect.selectedIndex = -1;
        const format = new ol.format.GeoJSON();
        const features = format.readFeatures(originalGeojson, {
          featureProjection: lccProjection,
          dataProjection: 'EPSG:4326'
        });
        officeLayer.getSource().clear();
        officeLayer.getSource().addFeatures(features);
        if (reachEnabled && officeLayer.getVisible()) rebuildOfficeHalos(originalGeojson);
      });

      regionSelect.addEventListener('change', applyFilters);
      buSelect.addEventListener('change', applyFilters);
    }

    // Legend
    function updateLegend() {
      const legendEl = document.getElementById('legend');
      const itemsEl = document.getElementById('legendItems');

      const anyUserLayers = uploadLayers.some(l => l.visible);

      if (!anyUserLayers && !officeLayer.getVisible()) {
        legendEl.style.display = 'none';
        itemsEl.innerHTML = '';
        return;
      }

      legendEl.style.display = '';
      itemsEl.innerHTML = '';

      if (officeLayer.getVisible()) {
        addLegendItem(itemsEl, '#009DE0', "Salas O'Brien Offices");
      }

      for (const l of uploadLayers) {
        if (!l.visible) continue;
        const color = l.pickr.getColor().toHEXA().toString();
        const name = document.getElementById(l.nameInputId).value || 'Layer';
        addLegendItem(itemsEl, color, name);
      }
    }

    function addLegendItem(container, color, name) {
      const row = document.createElement('div');
      row.className = 'legend-item';
      const sw = document.createElement('span');
      sw.className = 'legend-swatch';
      sw.style.background = color;
      const text = document.createElement('span');
      text.textContent = name;
      row.appendChild(sw);
      row.appendChild(text);
      container.appendChild(row);
    }

    // Upload layers
    function paletteColor(seed) {
      const palette = ['#000086', '#16a34a', '#ea580c', '#2563eb', '#0ea5e9', '#f59e0b'];
      return palette[(seed - 1) % palette.length];
    }

    document.getElementById('addLayerBtn').addEventListener('click', () => {
      if (layerCount >= MAX_LAYERS) {
        alert('You can add up to 3 layers.');
        return;
      }
      addUploadLayer();
      updateLegend();
    });

    function addUploadLayer() {
      const index = ++layerCount;
      const layerId = `uploaded-layer-${index}`;
      const defaultColor = paletteColor(index);
      const statusId = `status-${layerId}`;

      const card = document.createElement('div');
      card.className = 'layer-card';
      card.id = `card-${layerId}`;
      card.innerHTML = `
        <div class="layer-header">
          <div class="layer-meta">
            <input type="text" id="name-${layerId}" value="Layer ${index}" class="layer-name-input">
          </div>
          <div class="layer-actions">
            <button class="icon-btn" id="toggle-${layerId}" title="Toggle visibility">${ICON_EYE}</button>
            <button class="icon-btn" id="remove-${layerId}" title="Remove">✕</button>
          </div>
        </div>
        <div class="layer-body">
          <div class="layer-row">
            <div id="picker-${layerId}"></div>
            <label class="muted">Marker Color</label>
          </div>
          <div class="layer-row">
            <input type="file" id="file-${layerId}" accept=".csv">
          </div>
          <div id="${statusId}" class="muted"></div>
        </div>
      `;
      document.getElementById('uploadLayers').appendChild(card);

      const layer = new ol.layer.Vector({
        source: new ol.source.Vector(),
        style: new ol.style.Style({
          image: new ol.style.Circle({
            radius: 6,
            fill: new ol.style.Fill({ color: defaultColor }),
            stroke: new ol.style.Stroke({ color: "#EDEDED", width: 0.5 })
          })
        })
      });
      map.addLayer(layer);

      const pickr = Pickr.create({
        el: `#picker-${layerId}`,
        theme: 'classic',
        default: defaultColor,
        container: document.body,
        components: {
          preview: true,
          opacity: false,
          hue: true,
          interaction: { hex: true, input: true, save: true, cancel: true }
        }
      });

      let visible = true;
      const layerRecord = {
        id: layerId,
        layer: layer,
        nameInputId: `name-${layerId}`,
        pickr,
        get visible() { return visible; }
      };
      uploadLayers.push(layerRecord);

      pickr.on('change', (c) => {
        const color = c.toHEXA().toString();
        layer.setStyle(new ol.style.Style({
          image: new ol.style.Circle({
            radius: 6,
            fill: new ol.style.Fill({ color: color }),
            stroke: new ol.style.Stroke({ color: "#EDEDED", width: 0.5 })
          })
        }));
        updateLegend();
      });
      pickr.on('save', () => pickr.hide());

      document.getElementById(`toggle-${layerId}`).addEventListener('click', () => {
        visible = !visible;
        layer.setVisible(visible);
        document.getElementById(`toggle-${layerId}`).innerHTML = visible ? ICON_EYE : ICON_EYE_OFF;
        updateLegend();
      });

      document.getElementById(`remove-${layerId}`).addEventListener('click', () => {
        card.remove();
        map.removeLayer(layer);
        const idx = uploadLayers.findIndex(l => l.id === layerId);
        if (idx >= 0) uploadLayers.splice(idx, 1);
        layerCount--;
        document.getElementById('addLayerBtn').disabled = layerCount >= MAX_LAYERS;
        updateLegend();
      });

      document.getElementById(`name-${layerId}`).addEventListener('input', updateLegend);

      document.getElementById(`file-${layerId}`).addEventListener('change', (e) => {
        handleCSVUpload(e, layerRecord, document.getElementById(statusId));
      });

      if (layerCount >= MAX_LAYERS) {
        document.getElementById('addLayerBtn').disabled = true;
      }
    }

    function handleCSVUpload(event, layerRecord, statusEl) {
      const file = event.target.files[0];
      if (!file) return;

      statusEl.textContent = "Uploading…";

      Papa.parse(file, {
        header: true,
        skipEmptyLines: 'greedy',
        dynamicTyping: true,
        worker: true,
        complete: async (results) => {
          console.log('Parsed CSV:', results);
          console.log('First row:', results.data[0]);
          console.log('Column names:', results.meta.fields);
          
          const features = [];
          const color = layerRecord.pickr.getColor().toHEXA().toString();
          let skipped = 0;
          let geocoded = 0;

          for (const row of results.data) {
            // Try different possible column names
            let lat = parseFloat(row.Latitude || row.latitude || row.LAT || row.lat);
            let lng = parseFloat(row.Longitude || row.longitude || row.LNG || row.lng || row.LON || row.lon);
            
            console.log('Processing row:', { lat, lng, address: row.ADDRESS, row });

            // If no valid coordinates, try geocoding the address
            if ((!isFinite(lat) || !isFinite(lng)) && row.ADDRESS) {
              try {
                statusEl.textContent = `Geocoding addresses... (${geocoded + 1})`;
                const response = await fetch(
                  `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(row.ADDRESS)}&key=${GOOGLE_MAPS_KEY}`
                );
                const data = await response.json();
                if (data.status === "OK" && data.results[0]) {
                  lat = data.results[0].geometry.location.lat;
                  lng = data.results[0].geometry.location.lng;
                  geocoded++;
                  console.log('Geocoded:', row.ADDRESS, '→', lat, lng);
                } else {
                  console.warn('Geocoding failed for:', row.ADDRESS, data.status);
                }
              } catch (e) {
                console.warn("Geocoding error:", row.ADDRESS, e);
              }
            }

            if (isFinite(lat) && isFinite(lng)) {
              const feature = new ol.Feature({
                geometry: new ol.geom.Point(ol.proj.fromLonLat([lng, lat], lccProjection))
              });
              
              // Set properties
              feature.set('officeName', row["OFFICE NAME"] || row["LABEL"] || row.Name || row.name || "");
              feature.set('address', row.ADDRESS || row.Address || row.address || "");
              feature.set('color', color);
              
              features.push(feature);
            } else {
              skipped++;
              console.warn('Skipping row (no valid coords or address):', row);
            }
          }

          layerRecord.layer.getSource().clear();
          layerRecord.layer.getSource().addFeatures(features);

          const name = document.getElementById(layerRecord.nameInputId).value || 'Layer';
          if (features.length > 0) {
            statusEl.textContent = `✅ ${features.length} locations added to ${name}.`;
            if (geocoded > 0) {
              statusEl.textContent += ` (${geocoded} geocoded)`;
            }
            if (skipped > 0) {
              statusEl.textContent += ` (${skipped} skipped)`;
            }
          } else {
            statusEl.textContent = "⚠️ No valid locations found. Check your CSV format.";
          }

          updateLegend();
          event.target.value = "";
        },
        error: (err) => {
          console.error('Parse error:', err);
          statusEl.textContent = "❌ Upload failed: " + err.message;
        }
      });
    }

    // Template download
    document.getElementById('downloadTemplate').addEventListener('click', async (e) => {
      e.preventDefault();
      const url = "https://raw.githubusercontent.com/JLickteig/SalasOBrienOfficeMap/refs/heads/main/MapAddressTemplate.csv";
      try {
        const response = await fetch(url);
        const blob = await response.blob();
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = "MapAddressTemplate.csv";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      } catch (err) {
        console.error("Download failed:", err);
      }
    });

    // Revert map
    document.getElementById('revertMap').addEventListener('click', () => {
      for (const l of [...uploadLayers]) {
        map.removeLayer(l.layer);
        document.getElementById(`card-${l.id}`).remove();
      }
      uploadLayers.length = 0;
      layerCount = 0;
      document.getElementById('addLayerBtn').disabled = false;

      document.getElementById('regionFilter').selectedIndex = -1;
      document.getElementById('buFilter').selectedIndex = -1;
	  
	  // Reset country filter
setShowOtherCountries(false);

      if (originalGeojson) {
        const format = new ol.format.GeoJSON();
        const features = format.readFeatures(originalGeojson, {
          featureProjection: lccProjection,
          dataProjection: 'EPSG:4326'
        });
        officeLayer.getSource().clear();
        officeLayer.getSource().addFeatures(features);
      }

      if (reachEnabled && officeLayer.getVisible()) {
        rebuildOfficeHalos(originalGeojson);
      } else {
        setHaloData(emptyFC());
      }

      updateLegend();
    });

    // Export map
    document.getElementById('exportMap').addEventListener('click', () => {
      const panel = document.getElementById('panel');
      
      const prevPanelVis = panel.style.visibility;
      panel.style.visibility = 'hidden';

      const TARGET_AR = 21.278 / 12.889;

      const overlay = document.createElement('div');
      overlay.style.cssText = 'position:fixed; inset:0; z-index:9999; pointer-events:none;';

      const frame = document.createElement('div');
      Object.assign(frame.style, {
        position: 'absolute',
        top: '50%', left: '50%',
        width: '80%',
        aspectRatio: String(TARGET_AR),
        transform: 'translate(-50%, -50%)',
        outline: '2px dashed #666',
        outlineOffset: '0',
        pointerEvents: 'none',
        boxSizing: 'border-box'
      });
      overlay.appendChild(frame);

      const hint = document.createElement('div');
      hint.textContent = 'Pan and zoom the map, then confirm.';
      Object.assign(hint.style, {
        position: 'absolute', top: '15px', left: '50%', transform: 'translateX(-50%)',
        fontSize: '14px', color: '#fff', background: 'rgba(0,0,0,0.6)',
        padding: '6px 12px', borderRadius: '4px', pointerEvents: 'none'
      });
      overlay.appendChild(hint);

      const controlsWrap = document.createElement('div');
      Object.assign(controlsWrap.style, {
        position: 'absolute', bottom: '20px', right: '20px',
        display: 'flex', gap: '12px', alignItems: 'center',
        pointerEvents: 'auto'
      });

      const sizeLabel = document.createElement('span');
      sizeLabel.textContent = 'Frame size';
      sizeLabel.style.color = '#fff';
      sizeLabel.style.fontSize = '13px';

      const sizeSlider = document.createElement('input');
      sizeSlider.type = 'range';
      sizeSlider.min = '30';
      sizeSlider.max = '95';
      sizeSlider.value = '80';
      sizeSlider.step = '1';
      sizeSlider.style.width = '160px';
      sizeSlider.oninput = () => { frame.style.width = sizeSlider.value + '%'; };

      function makeBtn(txt) {
        const b = document.createElement('button');
        b.textContent = txt;
        b.className = 'so-btn';
        b.style.width = 'auto';
        return b;
      }
      const confirmBtn = makeBtn('Confirm Export');
      const cancelBtn = makeBtn('Cancel');

      controlsWrap.appendChild(sizeLabel);
      controlsWrap.appendChild(sizeSlider);
      controlsWrap.appendChild(confirmBtn);
      controlsWrap.appendChild(cancelBtn);
      overlay.appendChild(controlsWrap);
      document.body.appendChild(overlay);

      let exporting = false;

      confirmBtn.onclick = async () => {
        if (exporting) return;
        exporting = true;
        confirmBtn.disabled = true;
        confirmBtn.textContent = 'Exporting…';

        try {
          // Wait a moment for rendering
          await new Promise(r => setTimeout(r, 100));

          // Get the map canvas
          const mapContainer = document.getElementById('map');
          const canvases = mapContainer.querySelectorAll('canvas');
          
          if (!canvases.length) {
            throw new Error('No canvas found');
          }

          // Create composite canvas from all OpenLayers canvases
          const tempCanvas = document.createElement('canvas');
          const mapRect = mapContainer.getBoundingClientRect();
          const boxRect = frame.getBoundingClientRect();

          // Calculate crop area
          const scaleX = canvases[0].width / mapRect.width;
          const scaleY = canvases[0].height / mapRect.height;

          let sx = (boxRect.left - mapRect.left) * scaleX;
          let sy = (boxRect.top - mapRect.top) * scaleY;
          let sw = boxRect.width * scaleX;
          let sh = boxRect.height * scaleY;

          sx = Math.max(0, Math.floor(sx));
          sy = Math.max(0, Math.floor(sy));
          const ex = Math.min(canvases[0].width, Math.ceil(sx + sw));
          const ey = Math.min(canvases[0].height, Math.ceil(sy + sh));
          sw = Math.max(1, ex - sx);
          sh = Math.max(1, ey - sy);

          tempCanvas.width = sw;
          tempCanvas.height = sh;
          const ctx = tempCanvas.getContext('2d');

          // Draw all canvases onto temp canvas
          canvases.forEach(canvas => {
            if (canvas.width > 0) {
              ctx.drawImage(canvas, sx, sy, sw, sh, 0, 0, sw, sh);
            }
          });

          // Add legend if visible
          const legendEl = document.getElementById('legend');
          if (legendEl && legendEl.style.display !== 'none') {
            const legendCanvas = await html2canvas(legendEl, {
              backgroundColor: null,
              scale: scaleX,
              useCORS: true,
              logging: false
            });

            const lr = legendEl.getBoundingClientRect();
            const legendW = Math.round(lr.width * scaleX);
            const legendH = Math.round(lr.height * scaleX);

            let lmx = Math.round((sw - legendW) / 2);
            const desiredBottom = Math.round(30 * scaleX);
            let lmy = Math.max(0, sh - desiredBottom - legendH);

            lmx = Math.max(0, Math.min(lmx, sw - legendW));
            lmy = Math.max(0, Math.min(lmy, sh - legendH));

            ctx.drawImage(legendCanvas, lmx, lmy);
          }

          // Download
          const url = tempCanvas.toDataURL('image/png');
          const a = document.createElement('a');
          a.href = url;
          a.download = 'map export.png';
          a.click();

          cleanup();
        } catch (err) {
          console.error(err);
          alert('Export failed. Please try again.');
          confirmBtn.disabled = false;
          confirmBtn.textContent = 'Confirm Export';
          exporting = false;
        }
      };

      cancelBtn.onclick = () => cleanup();

      function cleanup() {
        document.body.removeChild(overlay);
        panel.style.visibility = prevPanelVis || '';
        exporting = false;
      }
    });
  </script>
</body>
</html>
