<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Salas O'Brien Offices Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- OpenLayers -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@latest/ol.css" />
  <script src="https://cdn.jsdelivr.net/npm/ol@latest/dist/ol.js"></script>

  <!-- Proj4 for Lambert Conformal Conic -->
  <script src="https://cdn.jsdelivr.net/npm/proj4@2.9.2/dist/proj4.js"></script>

  <!-- html2canvas for export -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

  <!-- Pickr (Color Picker) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/themes/classic.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/pickr.min.js"></script>

  <!-- Turf -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <!-- CSV parser -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>

  <style>
    :root {
      --brand: #009de0;
      --bg: #ffffff;
      --text: #111;
      --muted: #666;
      --line: #e5e7eb;
      --shadow: 0 4px 12px rgba(0,0,0,0.08);
      --radius: 14px;
    }

    * { box-sizing: border-box; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color: var(--text); }

    #map {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
    }

    #panel {
      position: absolute;
      top: 14px; left: 14px;
      width: 320px;
      max-height: calc(100vh - 28px);
      overflow: auto;
      background: var(--bg);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px;
      z-index: 5;
    }
    .panel-section {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 12px;
      margin-bottom: 12px;
      background: #fff;
    }
    .section-title {
      font-weight: 600;
      font-size: 14px;
      margin: 0 0 8px 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .hr { height: 1px; background: var(--line); margin: 12px 0; }

    .segmented {
      display: inline-flex;
      border: 1.5px solid var(--brand);
      border-radius: 999px;
      overflow: hidden;
      user-select: none;
    }
    .segmented button {
      padding: 8px 12px;
      font-size: 13px;
      border: none;
      background: #fff;
      color: var(--brand);
      cursor: pointer;
    }
    .segmented button.active { background: var(--brand); color: #fff; }

    .so-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      width: 100%;
      padding: 10px 14px;
      font-size: 14px;
      color: #000;
      background: #fff;
      border: 2px solid var(--brand);
      border-radius: 999px;
      cursor: pointer;
      transition: background .15s, color .15s;
    }
    .so-btn:hover { background: var(--brand); color: #fff; }

    .accordion { border: 1px solid var(--line); border-radius: 10px; overflow: hidden; margin-bottom: 10px; }
    .accordion-header {
      display: flex; align-items: center; justify-content: space-between;
      padding: 10px 12px; cursor: pointer; background: #f8fafc;
      font-weight: 600; font-size: 14px;
    }
    .chev { width: 12px; height: 12px; background: var(--brand); clip-path: polygon(100% 100%, 100% 0, 0 100%); transition: transform .15s; }
    .accordion-header[aria-expanded="true"] .chev { transform: rotate(45deg); }
    .accordion-body { display: none; padding: 10px; }
    .accordion-header[aria-expanded="true"] + .accordion-body { display: block; }

    label { font-size: 13px; font-weight: 600; }
    .subhead { color: var(--muted); font-size: 12px; }
    select { width: 100%; min-height: 160px; font-size: 13px; }
    .muted { color: var(--muted); font-size: 12px; }

    input[type="file"] { width: 100%; font-size: 13px; }
    input[type="file"]::file-selector-button {
      font-size: 12px; font-weight: 600; color: #000; background: #fff;
      border: 2px solid var(--brand); border-radius: 999px; padding: 6px 12px; margin-right: 10px; cursor: pointer;
      transition: background .15s, color .15s;
    }
    input[type="file"]::file-selector-button:hover { background: var(--brand); color: #fff; }

    .layer-card { border: 1px solid var(--line); border-radius: 10px; padding: 10px; margin-bottom: 10px; background: #fff; }
    .layer-header { display: flex; align-items: center; justify-content: space-between; gap: 8px; margin-bottom: 8px; }
    .layer-meta { display: flex; align-items: center; gap: 8px; min-width: 0; }
    .badge { font-size: 11px; color: #444; background: #f1f5f9; border:1px solid #e5e7eb; border-radius: 999px; padding: 2px 8px; }
    .layer-name-input { border:1px solid #e5e7eb; border-radius:8px; padding:6px 8px; width: 180px; }
    .layer-actions { display: flex; align-items: center; gap: 8px; }

    .icon-btn {
      background:#fff;
      border:1px solid var(--line);
      border-radius:8px;
      width:32px;
      height:32px;
      padding:0;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
    }
    .icon-btn:hover{ background:#f3f4f6; }
    .icon-btn svg{ width:18px; height:18px; display:block; fill:currentColor; }

    .layer-body { display: grid; gap: 8px; }
    .layer-row { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }

    .map-legend {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 14px;
      background: transparent;
      border-radius: 10px;
      padding: 8px 10px;
      z-index: 4;
      max-width: min(90%, 900px);
    }
    #legendItems { display: flex; align-items: center; justify-content: center; flex-wrap: wrap; gap: 10px 16px; }
    .legend-item { display: inline-flex; align-items: center; gap: 6px; }
    .legend-swatch { width: 14px; height: 14px; border-radius: 3px; display: inline-block; }

    .pcr-app { z-index: 10002; }

    #popup {
      position:absolute;
      background:white;
      border:1px solid #ccc;
      padding:6px 10px;
      font-size:12px;
      border-radius:6px;
      box-shadow:0 2px 6px rgba(0,0,0,0.2);
      pointer-events:none;
      display:none;
      z-index:10;
    }
  </style>
</head>
<body>
  <aside id="panel">
    <div class="panel-section">
      <div class="section-title">Coverage (3-hour drive)</div>
      <div class="segmented">
        <button id="reachOff" class="active">Hide Reach</button>
        <button id="reachOn">Show Reach</button>
      </div>
      <div class="muted" style="margin-top:6px;">Shows a 3-hour driving area around offices.</div>
    </div>

    <div class="panel-section">
      <div class="section-title">Filters</div>

      <div class="accordion">
        <div class="accordion-header" aria-expanded="false">
          <span>State / Province</span>
          <span class="chev"></span>
        </div>
        <div class="accordion-body">
          <label class="subhead">(Ctrl/Cmd + click for multiple)</label>
          <select id="regionFilter" multiple></select>
          <div style="margin-top:8px; display:flex; gap:8px;">
            <button class="so-btn" id="clearRegion">Clear</button>
          </div>
        </div>
      </div>

      <div class="accordion">
        <div class="accordion-header" aria-expanded="false">
          <span>Business Unit</span>
          <span class="chev"></span>
        </div>
        <div class="accordion-body">
          <select id="buFilter" multiple size="6"></select>
          <div style="margin-top:8px; display:flex; gap:8px;">
            <button class="so-btn" id="clearBU">Clear</button>
          </div>
        </div>
      </div>

      <div class="hr"></div>
      <button class="so-btn" id="clearFilters">Clear All Filters</button>
    </div>

    <div class="panel-section">
      <div class="section-title">Layers</div>

      <div class="layer-card">
        <div class="layer-header">
          <div class="layer-meta">
            <strong>Salas O'Brien Offices</strong>
            <span style="font-size:10px; color:#666">Built-in</span>
          </div>
          <div class="layer-actions">
            <button class="icon-btn" id="toggle-offices" title="Toggle visibility"></button>
          </div>
        </div>
        <div class="muted">This layer is filterable.</div>
      </div>

      <div id="uploadLayers"></div>

      <button class="so-btn" id="addLayerBtn">+ Add Layer</button>
      <div style="height:8px;"></div>
      <a href="#" id="downloadTemplate" class="muted" style="color:#E35920; font-weight: bold;">Download CSV template</a>
      <div class="muted" style="margin-top:6px;">
        Add up to 3 more layers. <br>
        <span style="color:#E35920; font-weight: bold;">NOTE</span> Template use is required.
      </div>
    </div>

    <div class="panel-section">
      <button class="so-btn" id="exportMap">Export Map as PNG</button>
      <button class="so-btn" id="revertMap" style="margin-top:8px;">Revert to Base Map</button>
    </div>
  </aside>

  <div id="map"></div>
  <div id="popup"></div>
  <div id="legend" class="map-legend" style="display:none;">
    <div id="legendItems"></div>
  </div>

  <script>
    // ADD YOUR GOOGLE MAPS API KEY HERE (WARNING: This is visible to anyone viewing your page source)
    const GOOGLE_MAPS_KEY = 'AIzaSyBZVs1es2OML0d7tQSw7BF38lUlx8-BW-U';
    
    const ICON_EYE = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640"><path d="M320 96C239.2 96 174.5 132.8 127.4 176.6C80.6 220.1 49.3 272 34.4 307.7C31.1 315.6 31.1 324.4 34.4 332.3C49.3 368 80.6 420 127.4 463.4C174.5 507.1 239.2 544 320 544C400.8 544 465.5 507.2 512.6 463.4C559.4 419.9 590.7 368 605.6 332.3C608.9 324.4 608.9 315.6 605.6 307.7C590.7 272 559.4 220 512.6 176.6C465.5 132.9 400.8 96 320 96zM176 320C176 240.5 240.5 176 320 176C399.5 176 464 240.5 464 320C464 399.5 399.5 464 320 464C240.5 464 176 399.5 176 320zM320 256C320 291.3 291.3 320 256 320C244.5 320 233.7 317 224.3 311.6C223.3 322.5 224.2 333.7 227.2 344.8C240.9 396 293.6 426.4 344.8 412.7C396 399 426.4 346.3 412.7 295.1C400.5 249.4 357.2 220.3 311.6 224.3C316.9 233.6 320 244.4 320 256z"/></svg>`;
    const ICON_EYE_OFF = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path d="M41-24.9c-9.4-9.4-24.6-9.4-33.9 0S-2.3-.3 7 9.1l528 528c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-96.4-96.4c2.7-2.4 5.4-4.8 8-7.2 46.8-43.5 78.1-95.4 93-131.1 3.3-7.9 3.3-16.7 0-24.6-14.9-35.7-46.2-87.7-93-131.1-47.1-43.7-111.8-80.6-192.6-80.6-56.8 0-105.6 18.2-146 44.2L41-24.9zM204.5 138.7c23.5-16.8 52.4-26.7 83.5-26.7 79.5 0 144 64.5 144 144 0 31.1-9.9 59.9-26.7 83.5l-34.7-34.7c12.7-21.4 17-47.7 10.1-73.7-13.7-51.2-66.4-81.6-117.6-67.9-8.6 2.3-16.7 5.7-24 10l-34.7-34.7zM325.3 395.1c-11.9 3.2-24.4 4.9-37.3 4.9-79.5 0-144-64.5-144-144 0-12.9 1.7-25.4 4.9-37.3L69.4 139.2c-32.6 36.8-55 75.8-66.9 104.5-3.3 7.9-3.3 16.7 0 24.6 14.9 35.7 46.2 87.7 93 131.1 47.1 43.7 111.8 80.6 192.6 80.6 37.3 0 71.2-7.9 101.5-20.6l-64.2-64.2z"/></svg>`;

    // Projection setup
    proj4.defs("EPSG:102009", "+proj=lcc +lat_1=33 +lat_2=45 +lat_0=39 +lon_0=-96 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs");
    ol.proj.proj4.register(proj4);
    const lccProjection = ol.proj.get("EPSG:102009");

    // Layers
    const baseLayer = new ol.layer.Vector({
      source: new ol.source.Vector({
        url: "https://raw.githubusercontent.com/JLickteig/SalasOBrienOfficeMap/main/mapbase.geojson",
        format: new ol.format.GeoJSON()
      }),
      style: new ol.style.Style({
        stroke: new ol.style.Stroke({ color: "#CCCCCC", width: 0.5 }),
        fill: new ol.style.Fill({ color: "#EDEDED" })
      })
    });

    const haloLayer = new ol.layer.Vector({
      source: new ol.source.Vector(),
      style: new ol.style.Style({
        fill: new ol.style.Fill({ color: 'rgba(0, 157, 224, 0.2)' })
      })
    });

    const officeLayer = new ol.layer.Vector({
      source: new ol.source.Vector({
        url: "https://raw.githubusercontent.com/JLickteig/SalasOBrienOfficeMap/main/offices.geojson",
        format: new ol.format.GeoJSON()
      }),
      style: new ol.style.Style({
        image: new ol.style.Circle({
          radius: 6,
          fill: new ol.style.Fill({ color: "#009DE0" }),
          stroke: new ol.style.Stroke({ color: "#EDEDED", width: 0.5 })
        })
      })
    });

    const map = new ol.Map({
      target: 'map',
      layers: [baseLayer, haloLayer, officeLayer],
      view: new ol.View({
        projection: lccProjection,
        center: ol.proj.fromLonLat([-105, 42], lccProjection),
        zoom: 5.25
      })
    });

    // State
    let originalGeojson = null;
    let reachEnabled = false;
    let layerCount = 0;
    const MAX_LAYERS = 3;
    const uploadLayers = [];
    const isoCache = new Map();

    // Popup
    const popupEl = document.getElementById('popup');
    map.on('pointermove', function (evt) {
      const feature = map.forEachFeatureAtPixel(evt.pixel, f => f);
      if (feature && feature.getGeometry().getType() === 'Point') {
        const p = feature.getProperties();
        const name = p["OFFICE NAME"] || p.officeName || p.LABEL || '';
        const address = p.ADDRESS || p.address || '';
        const phone = p["MAIN PHONE"] || '';
        const bu = p.BU || p.bu || '';
        const color = p.color || '#009DE0';

        popupEl.innerHTML = `
          <div style="line-height:1.2;">
            <div style="font-weight:bold; color:${color};">${name}</div>
            <div style="font-size:11px; color:#333;">${address}</div>
            ${phone ? `<div style="font-size:11px; color:#666;">${phone}</div>` : ''}
            ${bu ? `<div style="font-size:11px; color:#666;">${bu}</div>` : ''}
          </div>
        `;
        popupEl.style.left = evt.pixel[0] + 12 + 'px';
        popupEl.style.top = evt.pixel[1] + 12 + 'px';
        popupEl.style.display = 'block';
        map.getTargetElement().style.cursor = 'pointer';
      } else {
        popupEl.style.display = 'none';
        map.getTargetElement().style.cursor = '';
      }
    });

    // Accordion
    document.querySelectorAll('.accordion-header').forEach(h => {
      h.addEventListener('click', () => {
        const expanded = h.getAttribute('aria-expanded') === 'true';
        h.setAttribute('aria-expanded', String(!expanded));
      });
    });

    // Helper functions
    function emptyFC() {
      return { type: 'FeatureCollection', features: [] };
    }

    async function fetchIsochronePolygon(lng, lat) {
      const key = `${lng.toFixed(6)},${lat.toFixed(6)}`;
      if (isoCache.has(key)) return isoCache.get(key);
      const circle = turf.circle([lng, lat], 289.7, { steps: 128, units: 'kilometers' });
      isoCache.set(key, circle);
      return circle;
    }

    async function buildIsochronesForPoints(points) {
      const polys = [];
      for (const f of points) {
        const [lng, lat] = f.geometry.coordinates;
        const poly = await fetchIsochronePolygon(lng, lat);
        polys.push(poly);
      }
      return { type: 'FeatureCollection', features: polys };
    }

    function dissolvePolygons(fc) {
      if (!fc?.features?.length) return emptyFC();
      let merged = fc.features[0];
      for (let i = 1; i < fc.features.length; i++) {
        try {
          merged = turf.union(merged, fc.features[i]);
        } catch (e) {
          console.warn('union failed', e);
        }
      }
      return merged ? { type: 'FeatureCollection', features: [merged] } : emptyFC();
    }

    function setHaloData(fc) {
      const format = new ol.format.GeoJSON();
      const features = format.readFeatures(fc, {
        featureProjection: lccProjection,
        dataProjection: 'EPSG:4326'
      });
      haloLayer.getSource().clear();
      haloLayer.getSource().addFeatures(features);
    }

    async function rebuildOfficeHalos(sourceData) {
      if (!reachEnabled || !officeLayer.getVisible()) {
        setHaloData(emptyFC());
        return;
      }

      let features;
      if (sourceData) {
        features = sourceData.features;
      } else {
        const format = new ol.format.GeoJSON();
        const gj = format.writeFeaturesObject(officeLayer.getSource().getFeatures(), {
          featureProjection: lccProjection,
          dataProjection: 'EPSG:4326'
        });
        features = gj.features;
      }

      const pts = features.filter(f => f.geometry?.type === 'Point');
      if (!pts.length) {
        setHaloData(emptyFC());
        return;
      }

      const fc = await buildIsochronesForPoints(pts);
      const dissolved = dissolvePolygons(fc);
      setHaloData(dissolved);
    }

    // Reach toggle
    function setReach(enabled) {
      reachEnabled = enabled;
      document.getElementById('reachOn').classList.toggle('active', enabled);
      document.getElementById('reachOff').classList.toggle('active', !enabled);

      if (!enabled) {
        setHaloData(emptyFC());
      } else {
        rebuildOfficeHalos();
      }
    }

    document.getElementById('reachOn').addEventListener('click', () => setReach(true));
    document.getElementById('reachOff').addEventListener('click', () => setReach(false));

    // Office visibility toggle
    function updateOfficesToggleIcon(show) {
      const btn = document.getElementById('toggle-offices');
      btn.innerHTML = show ? ICON_EYE : ICON_EYE_OFF;
      btn.title = show ? 'Hide markers' : 'Show markers';
    }

    function setOfficesVisibility(show) {
      officeLayer.setVisible(show);
      if (!show) {
        setHaloData(emptyFC());
      } else if (reachEnabled) {
        rebuildOfficeHalos();
      }
      updateOfficesToggleIcon(show);
      updateLegend();
    }

    document.getElementById('toggle-offices').addEventListener('click', () => {
      setOfficesVisibility(!officeLayer.getVisible());
    });

    // Initialize
    setOfficesVisibility(true);

    // Load offices data
    officeLayer.getSource().once('change', function() {
      if (officeLayer.getSource().getState() === 'ready') {
        const format = new ol.format.GeoJSON();
        originalGeojson = format.writeFeaturesObject(officeLayer.getSource().getFeatures(), {
          featureProjection: lccProjection,
          dataProjection: 'EPSG:4326'
        });
        buildFilters(originalGeojson);
        updateLegend();
      }
    });

    // Filters
    function buildFilters(gj) {
      const regionSelect = document.getElementById('regionFilter');
      const buSelect = document.getElementById('buFilter');

      const states = [...new Set(gj.features.filter(f => f.properties.COUNTRY === 'US').map(f => f.properties["STATE / PROVINCE"]).filter(Boolean))].sort();
      const provinces = [...new Set(gj.features.filter(f => f.properties.COUNTRY === 'CAN').map(f => f.properties["STATE / PROVINCE"]).filter(Boolean))].sort();
      const bus = [...new Set(gj.features.map(f => f.properties.BU).filter(Boolean))].sort();

      const caGroup = document.createElement('optgroup');
      caGroup.label = 'Canada';
      provinces.forEach(p => {
        const o = document.createElement('option');
        o.value = 'CAN|' + p;
        o.textContent = p;
        caGroup.appendChild(o);
      });

      const usGroup = document.createElement('optgroup');
      usGroup.label = 'United States';
      states.forEach(s => {
        const o = document.createElement('option');
        o.value = 'US|' + s;
        o.textContent = s;
        usGroup.appendChild(o);
      });

      regionSelect.appendChild(caGroup);
      regionSelect.appendChild(usGroup);

      bus.forEach(b => {
        const o = document.createElement('option');
        o.value = b;
        o.textContent = b;
        buSelect.appendChild(o);
      });

      function getSelected(select) {
        return Array.from(select.selectedOptions).map(o => o.value);
      }

      async function applyFilters() {
        const regionsRaw = getSelected(regionSelect);
        const regions = regionsRaw.map(v => v.split('|')[1]);
        const busSel = getSelected(buSelect);

        const filtered = {
          type: 'FeatureCollection',
          features: originalGeojson.features.filter(f => {
            const props = f.properties || {};
            let ok = true;
            if (regions.length) {
              const code = props["STATE / PROVINCE"] || '';
              if (!regions.includes(code)) ok = false;
            }
            if (busSel.length && props.BU && !busSel.includes(props.BU)) ok = false;
            return ok;
          })
        };

        const format = new ol.format.GeoJSON();
        const features = format.readFeatures(filtered, {
          featureProjection: lccProjection,
          dataProjection: 'EPSG:4326'
        });
        officeLayer.getSource().clear();
        officeLayer.getSource().addFeatures(features);

        if (reachEnabled && officeLayer.getVisible()) await rebuildOfficeHalos(filtered);
      }

      document.getElementById('clearRegion').addEventListener('click', () => {
        regionSelect.selectedIndex = -1;
        applyFilters();
      });
      document.getElementById('clearBU').addEventListener('click', () => {
        buSelect.selectedIndex = -1;
        applyFilters();
      });
      document.getElementById('clearFilters').addEventListener('click', () => {
        regionSelect.selectedIndex = -1;
        buSelect.selectedIndex = -1;
        const format = new ol.format.GeoJSON();
        const features = format.readFeatures(originalGeojson, {
          featureProjection: lccProjection,
          dataProjection: 'EPSG:4326'
        });
        officeLayer.getSource().clear();
        officeLayer.getSource().addFeatures(features);
        if (reachEnabled && officeLayer.getVisible()) rebuildOfficeHalos(originalGeojson);
      });

      regionSelect.addEventListener('change', applyFilters);
      buSelect.addEventListener('change', applyFilters);
    }

    // Legend
    function updateLegend() {
      const legendEl = document.getElementById('legend');
      const itemsEl = document.getElementById('legendItems');

      const anyUserLayers = uploadLayers.some(l => l.visible);

      if (!anyUserLayers && !officeLayer.getVisible()) {
        legendEl.style.display = 'none';
        itemsEl.innerHTML = '';
        return;
      }

      legendEl.style.display = '';
      itemsEl.innerHTML = '';

      if (officeLayer.getVisible()) {
        addLegendItem(itemsEl, '#009DE0', "Salas O'Brien Offices");
      }

      for (const l of uploadLayers) {
        if (!l.visible) continue;
        const color = l.pickr.getColor().toHEXA().toString();
        const name = document.getElementById(l.nameInputId).value || 'Layer';
        addLegendItem(itemsEl, color, name);
      }
    }

    function addLegendItem(container, color, name) {
      const row = document.createElement('div');
      row.className = 'legend-item';
      const sw = document.createElement('span');
      sw.className = 'legend-swatch';
      sw.style.background = color;
      const text = document.createElement('span');
      text.textContent = name;
      row.appendChild(sw);
      row.appendChild(text);
      container.appendChild(row);
    }

    // Upload layers
    function paletteColor(seed) {
      const palette = ['#000086', '#16a34a', '#ea580c', '#2563eb', '#0ea5e9', '#f59e0b'];
      return palette[(seed - 1) % palette.length];
    }

    document.getElementById('addLayerBtn').addEventListener('click', () => {
      if (layerCount >= MAX_LAYERS) {
        alert('You can add up to 3 layers.');
        return;
      }
      addUploadLayer();
      updateLegend();
    });

    function addUploadLayer() {
      const index = ++layerCount;
      const layerId = `uploaded-layer-${index}`;
      const defaultColor = paletteColor(index);
      const statusId = `status-${layerId}`;

      const card = document.createElement('div');
      card.className = 'layer-card';
      card.id = `card-${layerId}`;
      card.innerHTML = `
        <div class="layer-header">
          <div class="layer-meta">
            <input type="text" id="name-${layerId}" value="Layer ${index}" class="layer-name-input">
          </div>
          <div class="layer-actions">
            <button class="icon-btn" id="toggle-${layerId}" title="Toggle visibility">${ICON_EYE}</button>
            <button class="icon-btn" id="remove-${layerId}" title="Remove">✕</button>
          </div>
        </div>
        <div class="layer-body">
          <div class="layer-row">
            <div id="picker-${layerId}"></div>
            <label class="muted">Marker Color</label>
          </div>
          <div class="layer-row">
            <input type="file" id="file-${layerId}" accept=".csv">
          </div>
          <div id="${statusId}" class="muted"></div>
        </div>
      `;
      document.getElementById('uploadLayers').appendChild(card);

      const layer = new ol.layer.Vector({
        source: new ol.source.Vector(),
        style: new ol.style.Style({
          image: new ol.style.Circle({
            radius: 6,
            fill: new ol.style.Fill({ color: defaultColor }),
            stroke: new ol.style.Stroke({ color: "#EDEDED", width: 0.5 })
          })
        })
      });
      map.addLayer(layer);

      const pickr = Pickr.create({
        el: `#picker-${layerId}`,
        theme: 'classic',
        default: defaultColor,
        container: document.body,
        components: {
          preview: true,
          opacity: false,
          hue: true,
          interaction: { hex: true, input: true, save: true, cancel: true }
        }
      });

      let visible = true;
      const layerRecord = {
        id: layerId,
        layer: layer,
        nameInputId: `name-${layerId}`,
        pickr,
        get visible() { return visible; }
      };
      uploadLayers.push(layerRecord);

      pickr.on('change', (c) => {
        const color = c.toHEXA().toString();
        layer.setStyle(new ol.style.Style({
          image: new ol.style.Circle({
            radius: 6,
            fill: new ol.style.Fill({ color: color }),
            stroke: new ol.style.Stroke({ color: "#EDEDED", width: 0.5 })
          })
        }));
        updateLegend();
      });
      pickr.on('save', () => pickr.hide());

      document.getElementById(`toggle-${layerId}`).addEventListener('click', () => {
        visible = !visible;
        layer.setVisible(visible);
        document.getElementById(`toggle-${layerId}`).innerHTML = visible ? ICON_EYE : ICON_EYE_OFF;
        updateLegend();
      });

      document.getElementById(`remove-${layerId}`).addEventListener('click', () => {
        card.remove();
        map.removeLayer(layer);
        const idx = uploadLayers.findIndex(l => l.id === layerId);
        if (idx >= 0) uploadLayers.splice(idx, 1);
        layerCount--;
        document.getElementById('addLayerBtn').disabled = layerCount >= MAX_LAYERS;
        updateLegend();
      });

      document.getElementById(`name-${layerId}`).addEventListener('input', updateLegend);

      document.getElementById(`file-${layerId}`).addEventListener('change', (e) => {
        handleCSVUpload(e, layerRecord, document.getElementById(statusId));
      });

      if (layerCount >= MAX_LAYERS) {
        document.getElementById('addLayerBtn').disabled = true;
      }
    }

    function handleCSVUpload(event, layerRecord, statusEl) {
      const file = event.target.files[0];
      if (!file) return;

      statusEl.textContent = "Uploading…";

      Papa.parse(file, {
        header: true,
        skipEmptyLines: 'greedy',
        dynamicTyping: true,
        worker: true,
        complete: async (results) => {
          console.log('Parsed CSV:', results);
          console.log('First row:', results.data[0]);
          console.log('Column names:', results.meta.fields);
          
          const features = [];
          const color = layerRecord.pickr.getColor().toHEXA().toString();
          let skipped = 0;
          let geocoded = 0;

          for (const row of results.data) {
            // Try different possible column names
            let lat = parseFloat(row.Latitude || row.latitude || row.LAT || row.lat);
            let lng = parseFloat(row.Longitude || row.longitude || row.LNG || row.lng || row.LON || row.lon);
            
            console.log('Processing row:', { lat, lng, address: row.ADDRESS, row });

            // If no valid coordinates, try geocoding the address
            if ((!isFinite(lat) || !isFinite(lng)) && row.ADDRESS) {
              try {
                statusEl.textContent = `Geocoding addresses... (${geocoded + 1})`;
                const response = await fetch(
                  `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(row.ADDRESS)}&key=${GOOGLE_MAPS_KEY}`
                );
                const data = await response.json();
                if (data.status === "OK" && data.results[0]) {
                  lat = data.results[0].geometry.location.lat;
                  lng = data.results[0].geometry.location.lng;
                  geocoded++;
                  console.log('Geocoded:', row.ADDRESS, '→', lat, lng);
                } else {
                  console.warn('Geocoding failed for:', row.ADDRESS, data.status);
                }
              } catch (e) {
                console.warn("Geocoding error:", row.ADDRESS, e);
              }
            }

            if (isFinite(lat) && isFinite(lng)) {
              const feature = new ol.Feature({
                geometry: new ol.geom.Point(ol.proj.fromLonLat([lng, lat], lccProjection))
              });
              
              // Set properties
              feature.set('officeName', row["OFFICE NAME"] || row["LABEL"] || row.Name || row.name || "");
              feature.set('address', row.ADDRESS || row.Address || row.address || "");
              feature.set('color', color);
              
              features.push(feature);
            } else {
              skipped++;
              console.warn('Skipping row (no valid coords or address):', row);
            }
          }

          layerRecord.layer.getSource().clear();
          layerRecord.layer.getSource().addFeatures(features);

          const name = document.getElementById(layerRecord.nameInputId).value || 'Layer';
          if (features.length > 0) {
            statusEl.textContent = `✅ ${features.length} locations added to ${name}.`;
            if (geocoded > 0) {
              statusEl.textContent += ` (${geocoded} geocoded)`;
            }
            if (skipped > 0) {
              statusEl.textContent += ` (${skipped} skipped)`;
            }
          } else {
            statusEl.textContent = "⚠️ No valid locations found. Check your CSV format.";
          }

          updateLegend();
          event.target.value = "";
        },
        error: (err) => {
          console.error('Parse error:', err);
          statusEl.textContent = "❌ Upload failed: " + err.message;
        }
      });
    }

    // Template download
    document.getElementById('downloadTemplate').addEventListener('click', async (e) => {
      e.preventDefault();
      const url = "https://raw.githubusercontent.com/JLickteig/SalasOBrienOfficeMap/refs/heads/main/MapAddressTemplate.csv";
      try {
        const response = await fetch(url);
        const blob = await response.blob();
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = "MapAddressTemplate.csv";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      } catch (err) {
        console.error("Download failed:", err);
      }
    });

    // Revert map
    document.getElementById('revertMap').addEventListener('click', () => {
      for (const l of [...uploadLayers]) {
        map.removeLayer(l.layer);
        document.getElementById(`card-${l.id}`).remove();
      }
      uploadLayers.length = 0;
      layerCount = 0;
      document.getElementById('addLayerBtn').disabled = false;

      document.getElementById('regionFilter').selectedIndex = -1;
      document.getElementById('buFilter').selectedIndex = -1;

      if (originalGeojson) {
        const format = new ol.format.GeoJSON();
        const features = format.readFeatures(originalGeojson, {
          featureProjection: lccProjection,
          dataProjection: 'EPSG:4326'
        });
        officeLayer.getSource().clear();
        officeLayer.getSource().addFeatures(features);
      }

      if (reachEnabled && officeLayer.getVisible()) {
        rebuildOfficeHalos(originalGeojson);
      } else {
        setHaloData(emptyFC());
      }

      updateLegend();
    });

    // Export map
    document.getElementById('exportMap').addEventListener('click', () => {
      map.once('rendercomplete', function() {
        const mapCanvas = document.createElement('canvas');
        const size = map.getSize();
        mapCanvas.width = size[0];
        mapCanvas.height = size[1];
        const mapContext = mapCanvas.getContext('2d');
        
        Array.prototype.forEach.call(
          map.getViewport().querySelectorAll('.ol-layer canvas, canvas.ol-layer'),
          function(canvas) {
            if (canvas.width > 0) {
              const opacity = canvas.parentNode.style.opacity || canvas.style.opacity;
              mapContext.globalAlpha = opacity === '' ? 1 : Number(opacity);
              
              let matrix;
              const transform = canvas.style.transform;
              if (transform) {
                matrix = transform.match(/^matrix\(([^\(]*)\)$/)[1].split(',').map(Number);
              } else {
                matrix = [
                  parseFloat(canvas.style.width) / canvas.width,
                  0,
                  0,
                  parseFloat(canvas.style.height) / canvas.height,
                  0,
                  0
                ];
              }
              CanvasRenderingContext2D.prototype.setTransform.apply(
                mapContext,
                matrix
              );
              const backgroundColor = canvas.parentNode.style.backgroundColor;
              if (backgroundColor) {
                mapContext.fillStyle = backgroundColor;
                mapContext.fillRect(0, 0, canvas.width, canvas.height);
              }
              mapContext.drawImage(canvas, 0, 0);
            }
          }
        );
        mapContext.globalAlpha = 1;
        mapContext.setTransform(1, 0, 0, 1, 0, 0);
        
        const link = document.createElement('a');
        link.download = 'map-export.png';
        link.href = mapCanvas.toDataURL();
        link.click();
      });
      map.renderSync();
    });
  </script>
</body>
</html>
